{"version":3,"file":"System.js","sourceRoot":"","sources":["../../../src/lib/utils/System.ts"],"names":[],"mappings":";;;;;;AAAA,4CAAoB;AAEpB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA+BE;AACF;;;;;;;;;;;;;;;;;EAiBE;AACF,SAAgB,UAAU,CAAC,IAAY;IACrC,IAAI;QACF,OAAO,YAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,YAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC;KAC3D;IACD,OAAO,KAAK,EAAE;QACZ,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAPD,gCAOC;AAED,SAAgB,SAAS,CAAC,IAAY;IACpC,IAAI;QACF,OAAO,YAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,YAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,WAAW,EAAE,CAAC;KAChE;IACD,OAAO,KAAK,EAAE;QACZ,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAPD,8BAOC;AAED,SAAgB,UAAU,CAAC,IAAY;IACrC,IAAI;QACF,OAAO,YAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,YAAE,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC;KAC3D;IACD,OAAO,KAAK,EAAE;QACZ,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAPD,gCAOC","sourcesContent":["import fs from 'fs';\n\n/*Export class ExecCommandError extends Error {\n  proc: ChildProcess;\n\n  constructor(proc: ChildProcess, err: Error) {\n    super();\n    this.name = 'ExecCommandError';\n    this.message = err.message;\n    this.stack = err.stack;\n    this.proc = proc;\n  }\n}\n\nexport function execCommand(cmd: string, sudo = false, logError = true, processCallback?: (proc: ChildProcess) => void) {\n  return new Promise<string>((resolve, reject) => {\n    pm.getLogger().info(`[peppymeter] Executing ${cmd}`);\n    const p = exec(sudo ? `echo volumio | sudo -S ${cmd}` : cmd, { uid: 1000, gid: 1000 }, function (error, stdout, stderr) {\n      if (error) {\n        if (logError) {\n          pm.getLogger().error(pm.getErrorMessage(`[peppymeter] Failed to execute ${cmd}: ${stderr.toString()}`, error));\n        }\n        reject(new ExecCommandError(p, error));\n      }\n      else {\n        resolve(stdout.toString());\n      }\n    });\n    if (processCallback) {\n      processCallback(p);\n    }\n  });\n}\n*/\n/*Export function spawnCommand(cmd: string, sudo = false, logOutput = true, processCallback?: (proc: ChildProcess) => void) {\n  const s = spawn(sudo ? `echo volumio | sudo -S ${cmd}` : cmd, { uid: 1000, gid: 1000 });\n  pm.getLogger().info(`[peppymeter] (PID: ${s.pid}) Spawned process for command: ${cmd}`);\n  s.stdout.on('data', (msg) => {\n    pm.getLogger().info(`[peppymeter] (PID: ${s.pid}) stdout: ${msg.toString()}`);\n  });\n  s.stderr.on('data', (msg) => {\n    pm.getLogger().info(`[peppymeter] (PID: ${s.pid}) stderr: ${msg.toString()}`);\n  });\n  s.on('close', (code, signal) => {\n    pm.getLogger().info(`[peppymeter] (PID: ${s.pid}) Closed - code: ${code}, signal: ${signal}`);\n  });\n  s.on('error', (err) => {\n    pm.getLogger().error(`[peppymeter] (PID: ${s.pid}) Error: ${err.message}`);\n\n  });\n}\n*/\nexport function fileExists(path: string) {\n  try {\n    return fs.existsSync(path) && fs.lstatSync(path).isFile();\n  }\n  catch (error) {\n    return false;\n  }\n}\n\nexport function dirExists(path: string) {\n  try {\n    return fs.existsSync(path) && fs.lstatSync(path).isDirectory();\n  }\n  catch (error) {\n    return false;\n  }\n}\n\nexport function fifoExists(path: string) {\n  try {\n    return fs.existsSync(path) && fs.lstatSync(path).isFIFO();\n  }\n  catch (error) {\n    return false;\n  }\n}"]}